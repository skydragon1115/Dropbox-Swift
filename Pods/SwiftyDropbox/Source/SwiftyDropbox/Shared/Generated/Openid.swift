///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the openid namespace
open class Openid {
    /// The AuthError union
    public enum AuthError: CustomStringConvertible {
        /// An unspecified error.
        case invalidToken
        /// An unspecified error.
        case noOpenidAuth
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AuthErrorSerializer().serialize(self)))"
        }
    }
    open class AuthErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AuthError) -> JSON {
            switch value {
                case .invalidToken:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_token")
                    return .dictionary(d)
                case .noOpenidAuth:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_openid_auth")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AuthError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_token":
                            return AuthError.invalidToken
                        case "no_openid_auth":
                            return AuthError.noOpenidAuth
                        case "other":
                            return AuthError.other
                        default:
                            return AuthError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// This struct is empty. The comment here is intentionally emitted to avoid indentation issues with Stone.
    open class UserInfoArgs: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoArgsSerializer().serialize(self)))"
        }
    }
    open class UserInfoArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfoArgs) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfoArgs {
            switch json {
                case .dictionary(_):
                    return UserInfoArgs()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UserInfoError struct
    open class UserInfoError: CustomStringConvertible {
        /// (no description)
        public let err: Openid.ErrUnion?
        /// (no description)
        public let errorMessage: String
        public init(err: Openid.ErrUnion? = nil, errorMessage: String = "") {
            self.err = err
            stringValidator()(errorMessage)
            self.errorMessage = errorMessage
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoErrorSerializer().serialize(self)))"
        }
    }
    open class UserInfoErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfoError) -> JSON {
            let output = [ 
            "err": NullableSerializer(Openid.ErrUnionSerializer()).serialize(value.err),
            "error_message": Serialization._StringSerializer.serialize(value.errorMessage),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfoError {
            switch json {
                case .dictionary(let dict):
                    let err = NullableSerializer(Openid.ErrUnionSerializer()).deserialize(dict["err"] ?? .null)
                    let errorMessage = Serialization._StringSerializer.deserialize(dict["error_message"] ?? .str(""))
                    return UserInfoError(err: err, errorMessage: errorMessage)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UserInfoResult struct
    open class UserInfoResult: CustomStringConvertible {
        /// (no description)
        public let familyName: String?
        /// (no description)
        public let givenName: String?
        /// (no description)
        public let email: String?
        /// (no description)
        public let emailVerified: Bool?
        /// (no description)
        public let iss: String
        /// (no description)
        public let sub: String
        public init(familyName: String? = nil, givenName: String? = nil, email: String? = nil, emailVerified: Bool? = nil, iss: String = "", sub: String = "") {
            nullableValidator(stringValidator())(familyName)
            self.familyName = familyName
            nullableValidator(stringValidator())(givenName)
            self.givenName = givenName
            nullableValidator(stringValidator())(email)
            self.email = email
            self.emailVerified = emailVerified
            stringValidator()(iss)
            self.iss = iss
            stringValidator()(sub)
            self.sub = sub
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoResultSerializer().serialize(self)))"
        }
    }
    open class UserInfoResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfoResult) -> JSON {
            let output = [ 
            "family_name": NullableSerializer(Serialization._StringSerializer).serialize(value.familyName),
            "given_name": NullableSerializer(Serialization._StringSerializer).serialize(value.givenName),
            "email": NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            "email_verified": NullableSerializer(Serialization._BoolSerializer).serialize(value.emailVerified),
            "iss": Serialization._StringSerializer.serialize(value.iss),
            "sub": Serialization._StringSerializer.serialize(value.sub),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfoResult {
            switch json {
                case .dictionary(let dict):
                    let familyName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["family_name"] ?? .null)
                    let givenName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["given_name"] ?? .null)
                    let email = NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                    let emailVerified = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["email_verified"] ?? .null)
                    let iss = Serialization._StringSerializer.deserialize(dict["iss"] ?? .str(""))
                    let sub = Serialization._StringSerializer.deserialize(dict["sub"] ?? .str(""))
                    return UserInfoResult(familyName: familyName, givenName: givenName, email: email, emailVerified: emailVerified, iss: iss, sub: sub)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ErrUnion union
    public enum ErrUnion: CustomStringConvertible {
        /// An unspecified error.
        case authError(Openid.AuthError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ErrUnionSerializer().serialize(self)))"
        }
    }
    open class ErrUnionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ErrUnion) -> JSON {
            switch value {
                case .authError(let arg):
                    var d = ["auth_error": Openid.AuthErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("auth_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ErrUnion {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "auth_error":
                            let v = Openid.AuthErrorSerializer().deserialize(d["auth_error"] ?? .null)
                            return ErrUnion.authError(v)
                        case "other":
                            return ErrUnion.other
                        default:
                            return ErrUnion.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

}
